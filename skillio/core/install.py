"""
Skillio Installation Module

Handles skill installation, removal, and management.
"""

import os
import json
import shutil
from pathlib import Path
from typing import Optional

from skillio.core.search import get_skill_info


def _get_default_install_path() -> Path:
    """Get the default skill installation path.
    
    Priority:
    1. SKILLIO_INSTALL_PATH env var
    2. ~/.cursor/skills/ (Cursor IDE)
    3. ~/.skillio/skills/ (standalone)
    """
    # Check env var
    env_path = os.environ.get("SKILLIO_INSTALL_PATH")
    if env_path:
        return Path(env_path)
    
    # Check for Cursor skills directory
    cursor_path = Path.home() / ".cursor" / "skills"
    if cursor_path.exists():
        return cursor_path
    
    # Default to skillio directory
    return Path.home() / ".skillio" / "skills"


def _get_installed_skills_registry() -> Path:
    """Get path to installed skills registry."""
    return _get_default_install_path().parent / "installed_skills.json"


def _load_installed_registry() -> dict:
    """Load the installed skills registry."""
    registry_path = _get_installed_skills_registry()
    
    if not registry_path.exists():
        return {"skills": {}}
    
    with open(registry_path, "r", encoding="utf-8") as f:
        return json.load(f)


def _save_installed_registry(registry: dict):
    """Save the installed skills registry."""
    registry_path = _get_installed_skills_registry()
    registry_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(registry_path, "w", encoding="utf-8") as f:
        json.dump(registry, f, indent=2)


def install_skill(
    skill_name: str,
    target: Optional[str] = None,
    force: bool = False
) -> dict:
    """Install a skill.
    
    Args:
        skill_name: Name of the skill to install
        target: Custom installation directory
        force: Force reinstall if already installed
    
    Returns:
        Result dict with success status and details
    """
    # Get skill info
    skill = get_skill_info(skill_name)
    if not skill:
        return {
            "success": False,
            "error": f"Skill '{skill_name}' not found in index"
        }
    
    # Determine install path
    install_base = Path(target) if target else _get_default_install_path()
    skill_path = install_base / skill_name
    
    # Check if already installed
    registry = _load_installed_registry()
    if skill_name in registry["skills"] and not force:
        return {
            "success": False,
            "error": f"Skill '{skill_name}' is already installed. Use --force to reinstall."
        }
    
    # Create skill directory
    skill_path.mkdir(parents=True, exist_ok=True)
    
    # Generate SKILL.md
    skill_md_content = _generate_skill_md(skill)
    skill_md_path = skill_path / "SKILL.md"
    
    with open(skill_md_path, "w", encoding="utf-8") as f:
        f.write(skill_md_content)
    
    # Update registry
    registry["skills"][skill_name] = {
        "version": skill.get("version", "1.0.0"),
        "path": str(skill_path),
        "source": skill.get("source", {}),
        "installed_at": str(Path.cwd())
    }
    _save_installed_registry(registry)
    
    return {
        "success": True,
        "path": str(skill_path),
        "version": skill.get("version", "1.0.0")
    }


def _generate_skill_md(skill: dict) -> str:
    """Generate SKILL.md content for a skill."""
    
    # Build capabilities list
    capabilities = "\n".join(f"- {cap}" for cap in skill.get("capabilities", []))
    
    # Build scenarios list
    scenarios = "\n".join(f"- {s}" for s in skill.get("scenarios", []))
    
    # Build dependencies
    deps = skill.get("dependencies", [])
    deps_section = ""
    if deps:
        deps_list = "\n".join(f"- {d}" for d in deps)
        deps_section = f"""
## Prerequisites

{deps_list}
"""
    
    # Get source info
    source = skill.get("source", {})
    source_type = source.get("type", "unknown")
    source_info = ""
    
    if source_type == "github":
        repo = source.get("repo", "")
        source_info = f"""
## Source

- GitHub: https://github.com/{repo}
- Type: {source_type}
"""
    
    content = f"""---
name: {skill['name']}
description: {skill['description']}
---

# {skill['name']}

{skill['description']}

{skill.get('description_zh', '')}

## Capabilities

{capabilities}

## Usage Scenarios

{scenarios}
{deps_section}{source_info}
## Quick Start

```bash
# Installation handled by Skillio
skillio install {skill['name']}
```

## Notes

- Quality Score: {skill.get('quality_score', 'N/A')}/10
- License: {skill.get('license', 'Unknown')}

---

*Generated by Skillio v0.1.0*
"""
    
    return content


def list_installed() -> list:
    """List all installed skills.
    
    Returns:
        List of installed skill info dicts
    """
    registry = _load_installed_registry()
    
    installed = []
    for name, info in registry.get("skills", {}).items():
        # Get full skill info
        skill = get_skill_info(name)
        if skill:
            skill["installed_path"] = info.get("path")
            installed.append(skill)
        else:
            # Skill removed from index but still installed
            installed.append({
                "name": name,
                "version": info.get("version", "unknown"),
                "description": "(Skill removed from index)",
                "installed_path": info.get("path")
            })
    
    return installed


def remove_skill(skill_name: str) -> dict:
    """Remove an installed skill.
    
    Args:
        skill_name: Name of the skill to remove
    
    Returns:
        Result dict with success status
    """
    registry = _load_installed_registry()
    
    if skill_name not in registry.get("skills", {}):
        return {
            "success": False,
            "error": f"Skill '{skill_name}' is not installed"
        }
    
    skill_info = registry["skills"][skill_name]
    skill_path = Path(skill_info.get("path", ""))
    
    # Remove skill directory
    if skill_path.exists():
        shutil.rmtree(skill_path)
    
    # Update registry
    del registry["skills"][skill_name]
    _save_installed_registry(registry)
    
    return {"success": True}
